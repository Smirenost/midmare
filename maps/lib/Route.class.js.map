{"version":3,"sources":["lib/Route.class.js","../lib/Route.class.ts"],"names":["Object","defineProperty","exports","value","Route","path_to_regexp_1","require","Route_1","[object Object]","path","middleware","options","this","name","stack","paramNames","regexp","pathToRegexp","Array","isArray","forEach","mw","method","toString","some","TypeError","test","captures","existingParams","params","len","length","i","param","fn","ctx","next","call","names","map","p","x","indexOf","splice","ignoreCaptures","match","slice","prefix","strict"],"mappings":"AAAA,aACAA,OAAOC,eAAeC,QAAS,aAAc,CAAEC,OAAO,IACtDD,QAAQE,WAAQ,ECFhB,MAAAC,iBAAAC,QAAA,kBAKA,IAAiBF,OAAjB,SAAiBG,GAOAA,EAAAH,MAAb,MAMII,YAAmBC,EAAcC,EAAgFC,EAAqB,IAQlI,GAReC,KAAAH,KAAAA,EAA8FG,KAAAD,QAAAA,EAL1GC,KAAAC,KAAe,GACfD,KAAAE,MAAiC,GAE9BF,KAAAG,WAAoB,GAG1BH,KAAKI,OAASX,iBAAAY,aAAaL,KAAKH,KAAMG,KAAKG,WAAYJ,GACvDC,KAAKE,MAAQI,MAAMC,QAAQT,GACvBA,EACA,CAACA,GAELE,KAAKE,MAAMM,QAAQC,GAAMA,EAAGR,OAASQ,EAAGC,OAASD,EAAGR,KAAKU,aAEtDX,KAAKE,MAAMU,KAAKH,GAAoB,mBAAPA,GAAoB,MAAMI,UAAU,iDAGxEjB,MAAMC,GACF,OAAOG,KAAKI,OAAOU,KAAKjB,GAG5BD,OAAOmB,EAAUC,GACb,MAAMC,EAASD,GAAkB,GACjC,IAAK,IAAIE,EAAMH,EAASI,OAAQC,EAAE,EAAGA,EAAEF,EAAKE,IACpCpB,KAAKG,WAAWiB,KAChBH,EAAOjB,KAAKG,WAAWiB,GAAGnB,MAAQc,EAASK,IAInD,OAAOH,EAGXrB,MAAOyB,EAAOC,GACV,MAAMpB,EAAQF,KAAKE,MACbe,EAASjB,KAAKG,WACdL,EAAa,SAAUyB,EAAsBC,GAC/C,OAAOF,EAAGG,KAAKzB,KAAMuB,EAAIN,OAAOI,GAAQE,EAAKC,IAGjD1B,EAAWuB,MAAQA,EAEnB,MAAMK,EAAQT,EAAOU,KAAI,SAAUC,GAC/B,OAAOA,EAAE3B,QAGP4B,EAAIH,EAAMI,QAAQT,GAYxB,OAXIQ,GAAK,GACL3B,EAAMU,KAAK,CAACH,EAAIW,MACPX,EAAGY,OAASK,EAAMI,QAAQR,EAAGD,OAASQ,KACvC3B,EAAM6B,OAAOX,EAAG,EAAGtB,IACZ,IAOZE,KAGXJ,SAAUC,GACN,OAAOG,KAAKD,QAAQiC,eAAiB,GAAKnC,EAAKoC,MAAMjC,KAAKI,QAAQ8B,MAAM,GAG5EtC,UAAWuC,GAOP,OANInC,KAAKH,OACLG,KAAKH,KAAsB,MAAdG,KAAKH,OAAwC,IAAxBG,KAAKD,QAAQqC,OAAmB,GAAGD,IAASnC,KAAKH,OAASsC,EAC5FnC,KAAKG,WAAa,GAClBH,KAAKI,OAASX,iBAAAY,aAAaL,KAAKH,KAAMG,KAAKG,WAAYH,KAAKD,UAGzDC,OA9EnB,CAAiBR,MAAAF,QAAAE,QAAAF,QAAAE,MAAK","file":"../../lib/Route.class.js","sourcesContent":["\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.Route=void 0;const path_to_regexp_1=require(\"path-to-regexp\");var Route;!function(t){t.Route=class{constructor(t,e,s={}){if(this.path=t,this.options=s,this.name=\"\",this.stack=[],this.paramNames=[],this.regexp=path_to_regexp_1.pathToRegexp(this.path,this.paramNames,s),this.stack=Array.isArray(e)?e:[e],this.stack.forEach(t=>t.name&&(t.method=t.name.toString())),this.stack.some(t=>\"function\"!=typeof t))throw TypeError(\"All middleware should have callback function.\")}match(t){return this.regexp.test(t)}params(t,e){const s=e||{};for(let e=t.length,a=0;a<e;a++)this.paramNames[a]&&(s[this.paramNames[a].name]=t[a]);return s}param(t,e){const s=this.stack,a=this.paramNames,r=function(s,a){return e.call(this,s.params[t],s,a)};r.param=t;const i=a.map((function(t){return t.name})),h=i.indexOf(t);return h>-1&&s.some((t,a)=>(!t.param||i.indexOf(e.param)>h)&&(s.splice(a,0,r),!0)),this}captures(t){return this.options.ignoreCaptures?[]:t.match(this.regexp).slice(1)}setPrefix(t){return this.path&&(this.path=\"/\"!==this.path||!0===this.options.strict?`${t}${this.path}`:t,this.paramNames=[],this.regexp=path_to_regexp_1.pathToRegexp(this.path,this.paramNames,this.options)),this}}}(Route=exports.Route||(exports.Route={}));\n//# sourceMappingURL=../maps/lib/Route.class.js.map\n","import {pathToRegexp, Key} from 'path-to-regexp';\nimport {Middleware} from \"./Middleware.class\";\nimport {Router} from \"./Router.class\";\nimport {Context} from \"./Context.class\";\n\nexport namespace Route {\n    import Dict = NodeJS.Dict;\n    import Path = Router.Path;\n    import NextCallback = Middleware.NextCallback;\n\n    export type AnyDict = { [key: string]: any };\n\n    export class Route {\n        public name: string = '';\n        public stack: Middleware.Middleware[] = [];\n        protected regexp: RegExp;\n        protected paramNames: Key[] = [];\n\n        constructor(public path: string, middleware: Middleware.Middleware[] | Middleware.Middleware, protected readonly options: Dict<any> = {} as AnyDict) {\n            this.regexp = pathToRegexp(this.path, this.paramNames, options);\n            this.stack = Array.isArray(middleware) ?\n                middleware :\n                [middleware];\n\n            this.stack.forEach(mw => mw.name && (mw.method = mw.name.toString()));\n\n            if(this.stack.some(mw => typeof mw !== 'function')) throw TypeError('All middleware should have callback function.');\n        }\n\n        match(path: Path) {\n            return this.regexp.test(path);\n        }\n\n        params(captures, existingParams) {\n            const params = existingParams || {};\n            for (let len = captures.length, i=0; i<len; i++) {\n                if (this.paramNames[i]) {\n                    params[this.paramNames[i].name] = captures[i];\n                }\n            }\n\n            return params;\n        }\n\n        param (param, fn) {\n            const stack = this.stack;\n            const params = this.paramNames;\n            const middleware = function (ctx: Context.Context, next: NextCallback) {\n                return fn.call(this, ctx.params[param], ctx, next);\n            } as Middleware.Middleware;\n\n            middleware.param = param;\n\n            const names = params.map(function (p) {\n                return p.name;\n            });\n\n            const x = names.indexOf(param);\n            if (x > -1) {\n                stack.some((mw, i) => {\n                    if (!mw.param || names.indexOf(fn.param) > x) {\n                        stack.splice(i, 0, middleware);\n                        return true;\n                    }\n\n                    return false;\n                });\n            }\n\n            return this;\n        };\n\n        captures (path) {\n            return this.options.ignoreCaptures ? [] : path.match(this.regexp).slice(1);\n        };\n\n        setPrefix (prefix) {\n            if (this.path) {\n                this.path = (this.path !== '/' || this.options.strict === true) ? `${prefix}${this.path}` : prefix;\n                this.paramNames = [];\n                this.regexp = pathToRegexp(this.path, this.paramNames, this.options);\n            }\n\n            return this;\n        };\n    }\n}"]}